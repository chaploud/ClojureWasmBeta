# 残タスク洗い出し（現状メモのレビュー＆整理版） <= 私が書き出したもの

## 1) リファクタリング（破壊を生まないためにインクリメンタルに）
- 目的: 変更の意図が追える／壊れにくい／読みやすい構造へ段階的に改善する
- Zigらしい構造・処理系らしい構造への寄せ
  - 既存の知見は `docs/reference/zig_guide.md` にまとめてある
  - ただしまとめた時期が古いので、Zig 0.15.2 時点での「より Zig らしい設計・機能活用」をプロジェクト横断で再点検する余地あり
- 不要ファイルのクリーンアップ（死んだコード／未使用ファイル／古い実験物）
- テストの整理（粒度・配置・命名・実行経路の統一）
- コード量の削減
  - 単なるコメント削除ではない（教育的コメントは残す）
  - 重複ロジックの統合、抽象化の適正化、責務分割で行数そのものを減らす方向
- 追加で拾えそうな「一般的なリファクタ項目」を軽く調べ、必要そうならタスクとして追加
  - 例: 依存関係の単純化、境界の明確化、命名規約・レイヤ規約、例外/エラー設計の整流化、ビルド構成の整理、CI整備 など

## 2) 高速化（観点を分けて、ベンチで前後比較しながら）
- 方針: 最初から全体最適化しない。ベンチマークを先に置いて「前後差分」で進める
- 観点A: Zigの書き方・機能活用による高速化
  - データ構造、アロケーション方針、境界チェック、分岐、inlining、コピー削減、メモリアクセス局所性…など（※具体化は後）
- 観点B: アルゴリズムによる高速化
  - 計算量・探索戦略・キャッシュ戦略など（※“速くなる理由”が説明できる単位で）
- 観点C: コンパイル／実行方法による高速化
  - ビルドフラグ、最適化モード、ターゲット設定、プロファイリング手法など（※後で体系化）
- ツリーウォーク系
  - 教育的価値が主なので「無理に最速を目指さない」
  - ただしボトルネックが致命的なら最低限の改善はあり
- バイトコードVM系
  - こちらは最適化の価値が高いが難易度も高い
  - 方針: 改善がコード全域に散らばらないように、最適化ポイントを分離して積み上げる（局所化・モジュール化）

## 3) GC・メモリ管理の高度化（長期稼働を前提に、性能と安定性を上げる）
- 目的: `.clj` ソフトが長期稼働しても破綻しにくい＆高速な実行環境へ
- GC方式の検討・導入
  - 世代別GC（推し）を含め、複数方式の比較検討
  - 「この処理系のメモリモデル／オブジェクト寿命」に合う方式を選ぶ
- Zig側の仕組み活用
  - Zigにカスタムアロケータがあるか／どう使うか（この時点では未確定なので要確認）
  - 使えるものは使いつつ、処理系としてのメモリ管理体系を設計する
- 実装は段階導入（いきなり完全置換しない）
  - 計測 → 仮説 → 導入 → 回帰確認、のループにする

## 4) 便利化（REPL体験・デバッグ体験を上げる）
- まずは本家 clj CLI のREPL機能を調べ、相当機能の優先順位を付ける
  - REPL補完
  - 履歴呼び出し
  - doc表示
  - doc検索
  - Var一覧
  - 名前空間doc
- エラーメッセージ／スタックトレースの親切化
  - babashka / SandboxClojureWasm / ClojureWasmAlpha で既に取り組み済みの知見を、このプロジェクトに馴染む形で取り込む

## 5) セルフホスト化（“今すぐ必須ではないが” 将来的に視野）
- 現時点では急がない可能性が高い（現段階では保留でよい）
- ただし `.clj` の読める範囲が増えてきたので、将来的には
  - Pureな関数の組み合わせ
  - 一部のマクロ
  などを `.clj` 側へ移譲していく方向性はあり得る

## 6) ドキュメント（用途別に分けて作る）
- 利用者向けドキュメント
  - インストール／起動／使い方／制約／例／FAQ
- 開発者向けドキュメント
  - アーキテクチャ、ビルド、テスト、設計方針、主要コンポーネント、デバッグ方法
- 発表・コミュニティ向け（ギーク寄り）ドキュメント
  - 全体構成（なぜこの構造か）
  - 工夫（設計上の判断、最適化ポイント、GCや実行モデルの選択理由）
  - 大局と細部（ストーリーと深掘りポイントの両方）

---

## メモの重複・日本語の整形方針（情報を落とさないための調整点）
- 「高速化」は “ツリーウォーク” と “VM” を明確に分けた（目的と難易度が違うため）
- 「Zigらしい構造」はリファクタ領域に寄せた（設計・構造タスクとして扱うほうがブレない）
- 「ベンチの前後を見る」は高速化の大原則として明文化した（進め方の軸）
- 「セルフホスト化」は“将来の候補”として扱い、今すぐの必須タスクと混ざらないようにした
- ドキュメントは目的別に3系統へ整理した（読者が違うため）

# 残タスク整理 <= これを受けてあなたが回答したもの

---

## 1. リファクタリング

### コード量削減・構造改善
- **core.zig ファイル分割** (10,700行超): `core/collections.zig`, `core/sequences.zig`, `core/wasm.zig` 等ドメイン分割。comptime テーブルは維持可能
- **value.zig の分割**: PersistentMap/PersistentVector/LazySeq 等を型ごとにファイル分割
- **switch exhaustiveness の集約**: Value variant 追加時に 6+ 箇所更新が必要。typeName/format 等をメソッドに集約
- **Wasm ローダー重複排除**: loadModule/loadModuleWithImports/loadWasiModule の共通部分をヘルパーに抽出
- **エラー伝播改善**: `catch { return error.XxxError }` で元エラーを捨てている箇所を `try` 活用に
- **anyopaque キャスト削減**: wasm 周りで zware 型を直接使える箇所の検討

### Zig 0.15.2 活用強化
- `zig_guide.md` は基礎カバー済みだがプロジェクト横断で更に活用できる点を調査
- `comptime` 活用度向上 (builtin テーブルのコンパイル時検証、名前重複チェック等)
- 不要ファイルのクリーンアップ

---

## 2. 高速化

### 前提: ベンチマーク基盤整備が最優先
- Phase Q6 で基盤作成済み。baseline 計測から開始
- fib(35), reduce over 100k, string concat 等の定番ベンチ

### Zig レベル
- Allocator 呼び出し頻度削減 (スタックバッファ活用: `var buf: [16]u64 = undefined;`)
- PersistentMap の線形走査 O(n) → HAMT or sorted array + binary search

### VM 最適化 (分離して進める)
- opcode dispatch: computed goto (`@call(.always_tail, ...)`)
- 定数畳み込み (Compiler 側、コアループ非侵襲)
- inline caching (侵襲的、後回し)
- TreeWalk は教育用として高速化対象外

---

## 3. GC・メモリ管理

### 現状の問題
- 式境界 Mark-Sweep: 長時間実行で pause 増大
- 短命オブジェクトも GC root 追跡対象

### 世代別 GC への道
- Young: bump allocator (超高速割り当て、minor GC で回収)
- Old: 現在の Mark-Sweep を流用
- write barrier 必要 (old → young 参照追跡)
- Zig カスタムアロケータインタフェースに乗せる (GcAllocator 拡張)

### Zig アロケータ活用
- ArenaAllocator (scratch 用、既存)
- FixedBufferAllocator (スタックフレーム用に余地あり)
- std.mem.Allocator インタフェースで自作アロケータ自然統合可能

---

## 4. 便利化 (REPL・UX)

### 本家 clj CLI 機能 (調査対象)
- Tab 補完 (namespace/var 名)
- 上下キー履歴 (readline/linenoise 相当)
- `(doc fn-name)`, `(find-doc "pattern")`, `(source fn-name)`
- `(dir ns-name)` — namespace public var 一覧
- `(apropos "pattern")` — 名前パターン Var 検索

### エラーメッセージ改善
- 現状 `error.TypeError` が多く情報不足
- babashka 式 "Expected X, got Y"
- スタックトレース (関数名 + ソース位置)。SourceInfo は Node に既存
- SandboxClojureWasm/ClojureWasmAlpha の成果物確認・取り込み

### 優先度
1. readline/履歴
2. doc/dir
3. エラーメッセージ改善
4. Tab 補完

---

## 5. セルフホスト化

- `load-file` + `require` が動いているので pure Clojure 関数は `.clj` に移せる素地あり
- 候補: juxt, comp, partial, keep, keep-indexed, mapcat, for 等 (現在マクロ展開実装)
- 性能トレードオフあり (Zig builtin → Clojure 関数呼び出し)。ベンチマーク後に判断
- 長期的にはブートストラップ `.clj` ファイル → 起動時 load-file

---

## 6. ドキュメント

### 利用者向け
- Getting Started (ビルド、CLI、REPL)
- 本家 Clojure との差分一覧 (未実装、挙動差異)
- Wasm 連携チュートリアル

### 開発者向け
- コード読み順ガイド (reader → analyzer → evaluator → vm)
- Value 型ライフサイクル図 (scratch → persistent, GC root)

### 発表用 (ギーク向け)
- 大局: 3フェーズ (Form→Node→Value)、デュアルバックエンド、--compare 回帰検出
- 設計判断: なぜ Zig、なぜ JVM interop 排除、なぜ zware
- 細部の工夫: comptime テーブル、threadlocal callback (call_fn/force_fn)、式境界 GC、LazySeq 段階的 force
- 数字: 760 テスト、549 core 関数、Wasm 10 関数

---

## 推奨優先度

1. ベンチマーク基盤整備 (全高速化・GC改善の前提)
2. core.zig ファイル分割 (開発体験の最大改善)
3. エラーメッセージ改善 (実用性直結)
4. REPL readline/履歴 (使い勝手改善)
5. 世代別 GC (長期稼働安定性)
6. VM 最適化 (ベンチマーク結果を見てから)
